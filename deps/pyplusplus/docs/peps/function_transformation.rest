========================
Function transformation
========================

.. contents:: Table of contents

-------------------
What is useful for?
-------------------

https://realityforge.vrsource.org/view/PyppApi/CodeInserter gives a nice introduction
and the problem description. Please read it.

-----------
Terminology
-----------

Lets say that we have a function ``f``:

::

  f = R f( A0 a0, ..., AN an )

``R`` and ``A*`` represent an arbitrary C++ types. What we want is to create
another function ``ft`` (transformed):

::

  ft = RT ft( AT0 at0, ..., ATM atm )

such that will do an additional work before and after ``f`` call.

Definitions
-----------

*Transformation* - process that defines how to create transformed function from the
original one.

For example - ``make function argument to be return value``:
::

  f = void get_last_error( int& error );

::

  ft = int get_last_error();

The definition of ``ft`` could look like:

.. code-block:: C++

  int get_last_error_transformed(){
      int error(0);
      get_last_error( error );
      return error;
  }

I modified ``f`` signature and added some code before and after ``f`` call.

*Function transformation* - group of transformations that should be applied at once
on a function.

For example a function could have two immutable arguments, passed by reference.
Function transformation aggregates two transformations.

A user will be able to define few function transformations for a single function.

-----------------------
Design & implementation
-----------------------

In the previous paragraph I introduced two new concepts: "transformation" and
"function transformation". These concepts should be presented in the solution.


Transformation
--------------

Transformation class has two responsibilities:

1. to modify function signature:

   * remove argument
   * change argument type
   * join arguments
   * change return type

2. to implement the transformation

It is important to distinct between the responsibilities. Function signature
defines "interface" for a lot of services provided by `Py++`_. While the second
one is "implementation details" and should be "hidden" from the rest of the world.

In an ideal world we would have 2 classes, one class - one responsibility.
In `Py++`_ it means that we would have ``transformation_t`` class:

.. code-block:: Python

  class transformation_t( object ):
      def __init__( self ):
          pass

.. code-block:: Python

      def check( self, function ):
          "checks whether the transformation could be applied on the function or not"
          raise NotImplementedError()

.. code-block:: Python

      def signature_changes( self, function ):
          "returns a list of changes that should be done on function signature"
          raise NotImplementedError()

The class logically belongs to the ``decl_wrappers`` package. The ``transformer_t``
is the second class, which logically belongs to ``code_creators`` package:

.. code-block:: Python

  class transformer_t( ast_visitor_t ):
      def __init__( self, function, transformation ):
          function is a reference to the declaration we want to apply transformation on
          transformation is an instance of "concrete" transformation

.. code-block:: Python

      def apply( self, function_body_as_tree ):
          "integrates transformation code to function body"
          raise NotImplementedError()

What is ``ast_visitor_t`` and ``function_body_as_tree``. In an ideal world
concrete instance of ``transformer_t`` class would work with some kind of AST
( Abstract Syntax Tree ). Thus transformer would travel on the tree and modify it.

Get the job done!
-----------------

The previously described solution will not work in our, `Py++`_ developers and
users, world. There are mainly two reasons:

1. AST approach is tooooooo complex. We don't have time to develop an AST for
   representing, even limited subset of C++ expressions. Users will not have
   time to learn how to use it.

2. Class separation approach will not work too. In order to introduce new
   transformation, user will have to understand the whole design of the `Py++`_
   package.

Matthias Baas provided a "real world" solution for both problems. At first I did
not understand it, but now I appreciate it very much. It does not meant that I
agree with the his implementation. As for me he did not stress enough the
concepts within the code and more over he mixed them in different classes.

I am going to propose another solution, which will be based on existing code.
Small re-factoring is needed. I don't expect changes in the user code.

Proposed class:

.. code-block:: Python

  class transformer_t( object ):
      "base class for all transformation classes"
      def __init__( self ):
          pass

.. code-block:: Python

      def check( self, function ):
          "checks whether the transformation could be applied on the function or not"
          raise NotImplementedError()

.. code-block:: Python

      def signature_changes( self, function ):
          "returns a list of changes that should be done on function signature"
          raise NotImplementedError()

.. code-block:: Python

      def apply( self, sm ): #sm is an instance of the substitution manager
          "integrates transformation code into function transformation body"
          raise NotImplementedError()

Comments:

1. ``substituion_manager_t`` class allows us to achieve same result as with AST.
   he way it does it is pretty simple to explain and understand - string
   substitution.

2. ``transformer_t`` class allows user to introduce new transformations, without
   understanding the whole `Py++`_ package.

Function trasformation
~~~~~~~~~~~~~~~~~~~~~~

What is responcibility of the ``function_transformation_t`` class?

1. To keep reference to transformations defined by the user.

2. To apply every transformation on the function body. For this purpose this
   class will keep instance of ``substituion_manager_t`` class.

3. To provide interface for ``mem_fun_v_transformed_t`` and
   ``mem_fun_v_transformed_wrapper_t`` code creators classes.

4. [Nice to have]To check, whether the transformation defined by user is
   applicable or not.

Somewhere we should put "function transformation" factory. This factory will
create or give a hint to the user what transformation could\\should be applied
on the function.

-------------------------------------
output_arg transformation example
-------------------------------------

.. code-block:: Python

  class output_arg_t( transformer_t ):
      def __init__( self, ordinal ):
          self.ordinal = ordinal

.. code-block:: Python

      def check( self, decl ):
          if len( decl.arguments ) <= self.ordinal:
              return user message
          type_ = decl.arguments[self.ordinal].type
          if not reference to immutable type:
              raise user message

.. code-block:: Python

      def signature_changes( self, decl ):
          assert not self.check( decl )
          return [ remove_arg( self.ordinal )
                   , add_var_to_return_value( decl.arguments[ self.ordinal ].name ]

.. code-block:: Python

      def apply( self, sm ):
          if sm is wrapper around C++ function:
              sm. add declaration of variable type = decl.arguments[ self.ordinal ].type
                  and name = decl.arguments[ self.ordinal ].type and initial value
              sm. add variable to return expression.
          else: #sm is a wrapper around Python function
              sm. extract value from the tuple and assign it to the argument

.. code-block:: Python

  def output_arg( ordinal ):
      return output_arg_t( ordinal )

-----------------
Problems to solve
-----------------

I don't have any solution to the next problems.

Call policies
-------------

I am going to change a little an example, from `Boost.Python`_ tutorials:
http://www.boost.org/libs/python/doc/tutorial/doc/html/python/functions.html#python.call_policies

.. code-block:: C++

  //C++ code
  struct Y
  {
      X x; Z* z;
      int z_value() { return z->value(); }
  };

.. code-block:: C++

  X& f(Y& y, Z* z, int& error)
  {
      y.z = z;
      return y.x;
  }

.. code-block:: C++

  //Boost.Python code
  def("f", f, return_internal_reference<1, with_custodian_and_ward<1, 2> >() );

What is the difference? Function ``f`` now takes 3rd argument - ``int&``. This
function could not be called from `Python`_. (Hint: numbers are immutable
objects in `Python`_ ). So in order to expose function ``f`` to `Python`_,
an user need to create a wrapper. And now he has a problem: how to wrap the function?

I see only one solution user have to change signature of function ``f``.
Now some speculations:

1. May be it is possible with `Boost.Python`_ library to set call policies on the
   part of the return value?

   .. code-block:: C++

     boost::tuple f_wrapper( Y& y, Z* z ){
         int error(0);
         X& x = f( y, z, error );
         return boost::tuple<X&, int>( x, error );
     }

    def("f", f_wrapper, smart call policies that will work only on first element within the tuple );

2. May be it is possible to create Boost.Python ``object`` with life-time management
   hint?

   .. code-block:: C++

     boost::python::tuple f_wrapper( Y& y, Z* z ){
         int error(0);
         X& x = f( y, z, error );
         boost::python::object x_obj( x, x is internal reference of y );
         return boost::python::make_tuple( x_obj, error );
     }

.. _`Py++` : ./../pyplusplus.html
.. _`Boost.Python`: http://www.boost.org/libs/python/doc/index.html
.. _`Python`: http://www.python.org
.. _`GCC-XML`: http://www.gccxml.org

..
   Local Variables:
   mode: indented-text
   indent-tabs-mode: nil
   sentence-end-double-space: t
   fill-column: 70
   End:

